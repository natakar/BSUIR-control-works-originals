.model small         ; модель памяти small  	
.data                     ; сегмент данных (упрощенная директива сегментации)  
mas db 1, 2, 3, 4, 5, 1, 8, 9, 13, 36, 27, 32, 92, 11, 55  ; объявление массива однобайтных чисел (нумерация – с 0)
res dw $-offset mas ; res –  переменная - количество четных элементов
.stack 100h          ; под стек отвели 256 байт 
.code                  ; начало сегмента кода 
start:                 ; метка. начало программы
mov ax, @data      ; занесение адреса сегмента данных в регистр ax. 
mov ds, ax         ; копируем содержимое регистра ax в регистр ds, напрямую	     
       		       ; загрузить инфу в ds нельзя, можно из режимов адресации
lea si, mas  ; загрузили в si смещение переменной mas командой lea.
mov cx, res   ; в сх будет накапливаться число четных элементов 
cld                	; сброс в 0 DF – значение di б увеличивать	
xor ax, ax     ; обнуление регистра ах, это эффективнее для обнуления, чем команда mov ax, 0  
M: lodsb   ; lods загружает байт (на который указывает пара регистров ds:esi/si) в регистр al (lodsb)
  and al, 1
  sub res, ax
  loop M        ; команда организации цикла loop – конец цикла
  mov ax, res   ; переложили в регистр ах количество оставшихся элементов
  aam           ; коррекция неупакованного BCD-числа
  add ax, '00'
  mov dl, ah    ; формируем ответ
  mov dh, al
    mov ah, 02h ; выводим полученное  число четных чисел на экран: вывод на консоль имеет свой адрес, на него с помощью mov отправляется байт для отображения. 
	int 21h     ; вызываем прерывание ОС DOS, идёт вывод строки текста 
  mov dl, dh
  int 21h       ; прерывание 
  mov ax,  4c00h ; функция 4ch означает завершение работы  проги и возврат в с-му DOS (корректный выход из программы в DOS)
  int 21h        ; выход из программы
  end start      ; конец программы (закрыть программу)
  
  
  
  
  
  
  
  
  
  
  
